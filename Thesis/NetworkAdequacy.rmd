---
output:
  pdf_document: default
  html_document: default
---
## Network Adequacy

The trilateration index was originally designed to improve efficiency of the "network adequacy" (NA) problem for health care.  Network adequacy is a common legal requirement for medicare or insurance companies with constraints such as:

* 90% of members must live within 50 miles of a covered emergency room
* 80% of female members over the age of 13 must live within 25 miles of a covered OB/GYN
* 80% of members under the age of 16 must live within 25 miles of a covered pediatrician
* etc.

Note that these are all illustrative examples; the real "Medicare Advantage Network Adequacy Criteria Guidance" document for example, is a 75 page document.

Similar requirements, legal or otherwise, show up in cellular network and satellite communication technology (numbers are illustrative):

* Maximize the number of people living within 10 miles of a 5G cell tower
* 100% of all major highways should be within 5 miles of a 4G cell tower
* There must be at least 2 satellites within 200 km of a point 450 km directly above every ground station for satellite network connectivity at any given time
* There must be at least 1 satellite with access to a ground station within 50 km of a point 450 km directly above as many households as possible at any given time

The nearest-neighbor problem was called the "Post-Office Problem" in early incarnations, and the system of post offices lends itself to a similar construction:
* Ensure that all US Postal addresses are within range of a post office 

and so forth.


### Formalization of Network Adequacy

We formalize the concept of "Network Adequacy" as:

#### Network Adequacy Definition

Given a non-empty set of points $P$ and a non-empty set of query points $Q$ in a metric space $M$ (where $P \cap Q$ comprises the 'network'), the network is 'completely adequate' for a distance $d$ and a distance function $D(a, b)$ describing the distance between points $a$ and $b$ for $a \in M$ and $b \in M$ if for every point $q$ (where $q \in Q$) $\exists$ at least one point $p$ ($p \in P$) $\ni D(p, q) <= d$.  Otherwise the network is 'inadequate'.

We call a single point $q$ 'adequate' itself, if it satisfies the same condition -- i.e. $\exists$ at least one point $p$ ($p \in P$) $D(p, q) <= d$.


#### Network Adequacy Percent

If, within $P$, we consider the largest subset $P' \in P$ where $P'$ is 'completely adequate',  then $P$ has a "Network Adequacy Percent (NAP)" of $|P'|/|P|$.  Note that $P'$ can be defined (identically) as the union of all 'adequate' points $p \in P$.

#### Network Adequacy Threshold
We can generalize this slightly more by describing a network as 'adequate with threshold $T$' by introducing a percent $T$ ($0<=T<=1$) such that the same network is adequate if at least $T*|Q|$ (or $T$ percent of points in $Q$) are individually 'adequate'.

Another way of saying this is that the netwrk is 'adequate with threshold $T$' if the Network Adequacy Percent ${NAP} > T$.

In this case, if $T == 1$ we have the original case.  If $T == 0$ we have a trivial case where the network is always adequate (even if $Q$ and/or $P$ are empty, which is generally disallowed).

#### k-Network Adequacy (kNA)

Similarly to the $kNN$ extension of nearest-neighbor search, where we want the $k$ nearest values, a $k$-network adequacy problem could be stated:

Given $P$ and $Q$ as before, a network is 'completely k-adequate' for a given $k$ if $\exists$ at least $k$ points $p \in P$ $\ni D(p, q) <= d$.  Otherwise the network is 'k-inadequate'.

Similarly, a single point $q$ is 'k-adequate' itself, if it satisfies the same condition -- i.e. $\exists$ at least $k$ points $p \in P \ni D(p, q) <= d$.  Otherwise the point is 'k-inadequate'.


#### Solving NA Using NN Algorithms

Generally, using $NN$ techniques, the brute-force is iterative: for each point $q$, find the nearest point $p$ and if $D(p, q) < d$ count it as conforming, otherwise count it as non-conforming. We then calculate the ratio of $r = \frac{conforming} {|Q|}$ to determing whether $r >= T$ or not.

If we set $m = |Q|$ and $n = |P|$, and if we use a Nearest-Neighbor algorithm with $O(n\ log\ n)$ then the time complexity for Network Adequacy becomes $O(m*n\ log\ n)$.

In the worst-case, we cannot improve on this, however we can introduce what we believe are novel algorithms, based on the Trilateration Index, which execute efficiently compared to this iterative approach, by deeply reducing the search space and number of times the distance functions must be called in typical real-world cases.  Also, trivially, it is unnecessary to find the nearest point $p$, merely prove that at least one such point exists (or none exists) for a given $q$.


## Multilateration NA Algorithms

In SQL, we implement two $NA$ algorithms to compare this theoretical setup to a typical real-world example detecting whether there exists a record in $P$ within $d$ of each of a set of query points $Q$:

* "NAIVE-NA" - the default SQL Query algorithm
* "TRILAT-NA" - the approach we've described

### NAIVE-NA
The most basic SQL query, in a database that has Geospatial extensions, to calculate Network Adequacy is something like:

```{SQL naive_na, attr.source='.numberLines'}
    select count(q.sampleid) as qcount,
        count(p2.sampleid) as tcount
    from q_points q
    left join lateral (select p.sampleid from p_points p
        where
          st_distance(p.st_geompoint, q.st_geompoint) <= (1609.34 * mydist)
        limit 1
    ) p2 on true
```

This assumes two tables - "q_points" and "p_points" containing the points in $Q$ and $P$ respectively.  Each has a field "st_geompoint" containing a geospatial position for each point.  The "st_distance" function is a SQL function to calculate the distance between two points - in our case we need to ensure the database uses the accurate Geodesic calculation from our research.[@Karney2013]

This returns the number of records in $Q$ as qcount and the number of records in $P$ as tcount.  The Network Adequacy Percent is then $\frac{tcount}{qcount}$.

Note that this function is in PostgreSQL syntax; it requires slight moderation but otherwise works (we tested) in Microsoft SQL Server and MySQL.  It likely works with little modification in any database which supports the SQL:1999 standard for lateral joins and geospatial points and distance functions.  One thing that is NOT identical between database implementations is the ability or effectiveness of database indexes on this query.  In postgres, we have experimented and found that 

Also note the $1609.34$ - this is to convert the distance from meters to miles, which is not core to the algorithm, but left here since these are the units we work with in our experimental results, and as an example.


### TRILAT-NA

Recall that we require fixed reference points for Trilateration, and per our previous construction, we selected these:

* Point 1: $90.000000, 0.000000$ (The geographic north pole) 
* Point 2: $38.260000, -85.760000$ (Louisville, KY on the Ohio River) 
* Point 3: $-19.22000, 159.93000$ (Sandy Island, New Caledonia)

The "NAIVE-NA" query requires no real setup, other than storing the data from the $P$ and $Q$ datasets.  Not so here -- we require additional fields added to the database in the q_points and p_points tables to store the distances from each point to these reference points.  We name those fields $refdist1$, $refdist2$, and $refdist3$.  Recall that this is a one-time setup requiring $3*|P|+3*|Q|$ calls to st_distance.

The SQL implementation of the TRILAT-NA algorithm then looks like this:

```{SQL trilat_na, attr.source='.numberLines'}
    select count(q.sampleid) as qcount,
        count(p2.sampleid) as tcount
    from q_points q
    left join lateral (select p.sampleid from p_points p
        where
          abs(q.refdist1 - p.refdist1) <= (1609.34 * mydist)
          and abs(q.refdist2 - p.refdist2) <= (1609.34 * mydist)
          and abs(q.refdist3 - p.refdist3) <= (1609.34 * mydist)
          and st_distance(p.st_geompoint, q.st_geompoint) <= (1609.34 * mydist)
        limit 1
    ) p2 on true
```

Note that this is identical to the query for NAIVE-NA, with the addition of the three lines comparing the refdist values.

These accomplish two things:

1.  They allow SQL to optimize using normal (non-geospatial) database indexes when comparing between the two points $p$ and $q$, using simple subtraction rather than a complicated geodesic query.  
2.  They allow for three opportunities to reduce the dataset size before the high cost geodesic query is performed.  Recall our figure [Monte Carlo Estimating Ring Overlap Area] that exhibited how the area of the three overlapping rings of width $d$ was $<<$ the area of the search space; a similar thing happens here... For a given distance $d$, the set of points where $q.refdist_i - p.refdist_i <= d$, is the intersection of those three rings of width $d$ with centers on the three reference points and with diameters such that the middle of each ring passes through $q$.  This eliminates most points if $d$ is relatively small - small enough that some points $q$ are inadequate is generally a good test.

See the [Experimentation] and [Experimental Results] sections for details on our specific implementations, tests, and results.